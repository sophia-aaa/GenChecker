We have 3 patterns.<br>
1. functions with reused codes<br>
2. switch-statement with reused cases<br>
3. function with reflect.SliceHeader and the return value is an interface type<br>


If you give a command on the terminal like this "go run main.go - "dataset/getset.go",<br>
then the following command will show whether the above patterns exist.<br>
E.g.<br>
For the first pattern:<br>
go run main.go - "dataset/getset.go"<br>
These functions have a same structure and the code are reused: Bools Ints Int8s Int16s Int32s Int64s Uints Uint8s Uint16s Uint32s Uint64s Uintptrs Float32s Float64s Complex64s Complex128s Strings UnsafePointers<br>
<br><br>
The second pattern looks like:<br>
go run main.go - "dataset/eng_reduce.go"<br>
<br>
The function  ReduceFirst  can be replaced by Generics and the cases which will be replaced by generics are:<br>
[Bool] [Int] [Int8] [Int16] [Int32] [Int64] [Uint] [Uint8] [Uint16] [Uint32] [Uint64] [Uintptr] [Float32] [Float64] [Complex64] [Complex128] [String] [UnsafePointer]<br>
<br><br>
The last pattern would be displayed on the terminal: <br>
go run main.go - "dataset/array.go"  <br>
...<br>
There exists (a) function(s) with reflect.SliceHeader and Interface of return value. It recommends to use Generics Slice : Data
<br>
