// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 07 Oct 2019 13:59:36 CDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ultralight

/*
#cgo CFLAGS: -I../include
#cgo windows,386 LDFLAGS: -L${SRCDIR}/libs/windows/x32
#cgo windows,amd64 LDFLAGS: -L${SRCDIR}/libs/windows/x64 
#cgo darwin,amd64 LDFLAGS: -L${SRCDIR}/libs/darwin/x64 
#cgo linux,amd64 LDFLAGS: -L${SRCDIR}/libs/linux/x64 
#cgo LDFLAGS: -lUltralightCore -lWebCore -lUltralight -lAppCore
#include "AppCore/CAPI.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

func (x ULUpdateCallback) PassRef() (ref *C.ULUpdateCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateCallback7E1C6355Func == nil {
		uLUpdateCallback7E1C6355Func = x
	}
	return (*C.ULUpdateCallback)(C.ULUpdateCallback_7e1c6355), nil
}

func (x ULUpdateCallback) PassValue() (ref C.ULUpdateCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateCallback7E1C6355Func == nil {
		uLUpdateCallback7E1C6355Func = x
	}
	return (C.ULUpdateCallback)(C.ULUpdateCallback_7e1c6355), nil
}

func NewULUpdateCallbackRef(ref unsafe.Pointer) *ULUpdateCallback {
	return (*ULUpdateCallback)(ref)
}

//export uLUpdateCallback7E1C6355
func uLUpdateCallback7E1C6355(cuser_data unsafe.Pointer) {
	if uLUpdateCallback7E1C6355Func != nil {
		user_data7e1c6355 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		uLUpdateCallback7E1C6355Func(user_data7e1c6355)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLUpdateCallback7E1C6355Func ULUpdateCallback

func (x ULCloseCallback) PassRef() (ref *C.ULCloseCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLCloseCallback195B2F9Func == nil {
		uLCloseCallback195B2F9Func = x
	}
	return (*C.ULCloseCallback)(C.ULCloseCallback_195b2f9), nil
}

func (x ULCloseCallback) PassValue() (ref C.ULCloseCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLCloseCallback195B2F9Func == nil {
		uLCloseCallback195B2F9Func = x
	}
	return (C.ULCloseCallback)(C.ULCloseCallback_195b2f9), nil
}

func NewULCloseCallbackRef(ref unsafe.Pointer) *ULCloseCallback {
	return (*ULCloseCallback)(ref)
}

//export uLCloseCallback195B2F9
func uLCloseCallback195B2F9(cuser_data unsafe.Pointer) {
	if uLCloseCallback195B2F9Func != nil {
		user_data195b2f9 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		uLCloseCallback195B2F9Func(user_data195b2f9)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLCloseCallback195B2F9Func ULCloseCallback

func (x ULResizeCallback) PassRef() (ref *C.ULResizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLResizeCallback6E7309D9Func == nil {
		uLResizeCallback6E7309D9Func = x
	}
	return (*C.ULResizeCallback)(C.ULResizeCallback_6e7309d9), nil
}

func (x ULResizeCallback) PassValue() (ref C.ULResizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLResizeCallback6E7309D9Func == nil {
		uLResizeCallback6E7309D9Func = x
	}
	return (C.ULResizeCallback)(C.ULResizeCallback_6e7309d9), nil
}

func NewULResizeCallbackRef(ref unsafe.Pointer) *ULResizeCallback {
	return (*ULResizeCallback)(ref)
}

//export uLResizeCallback6E7309D9
func uLResizeCallback6E7309D9(cuser_data unsafe.Pointer, cwidth C.uint, cheight C.uint) {
	if uLResizeCallback6E7309D9Func != nil {
		user_data6e7309d9 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		width6e7309d9 := (uint32)(cwidth)
		height6e7309d9 := (uint32)(cheight)
		uLResizeCallback6E7309D9Func(user_data6e7309d9, width6e7309d9, height6e7309d9)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLResizeCallback6E7309D9Func ULResizeCallback

func (x ULChangeTitleCallback) PassRef() (ref *C.ULChangeTitleCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTitleCallbackBD58034CFunc == nil {
		uLChangeTitleCallbackBD58034CFunc = x
	}
	return (*C.ULChangeTitleCallback)(C.ULChangeTitleCallback_bd58034c), nil
}

func (x ULChangeTitleCallback) PassValue() (ref C.ULChangeTitleCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTitleCallbackBD58034CFunc == nil {
		uLChangeTitleCallbackBD58034CFunc = x
	}
	return (C.ULChangeTitleCallback)(C.ULChangeTitleCallback_bd58034c), nil
}

func NewULChangeTitleCallbackRef(ref unsafe.Pointer) *ULChangeTitleCallback {
	return (*ULChangeTitleCallback)(ref)
}

//export uLChangeTitleCallbackBD58034C
func uLChangeTitleCallbackBD58034C(cuser_data unsafe.Pointer, ccaller C.ULView, ctitle C.ULString) {
	if uLChangeTitleCallbackBD58034CFunc != nil {
		user_databd58034c := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		callerbd58034c := *(*ULView)(unsafe.Pointer(&ccaller))
		titlebd58034c := *(*ULString)(unsafe.Pointer(&ctitle))
		uLChangeTitleCallbackBD58034CFunc(user_databd58034c, callerbd58034c, titlebd58034c)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeTitleCallbackBD58034CFunc ULChangeTitleCallback

func (x ULChangeURLCallback) PassRef() (ref *C.ULChangeURLCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeURLCallback4EC32B80Func == nil {
		uLChangeURLCallback4EC32B80Func = x
	}
	return (*C.ULChangeURLCallback)(C.ULChangeURLCallback_4ec32b80), nil
}

func (x ULChangeURLCallback) PassValue() (ref C.ULChangeURLCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeURLCallback4EC32B80Func == nil {
		uLChangeURLCallback4EC32B80Func = x
	}
	return (C.ULChangeURLCallback)(C.ULChangeURLCallback_4ec32b80), nil
}

func NewULChangeURLCallbackRef(ref unsafe.Pointer) *ULChangeURLCallback {
	return (*ULChangeURLCallback)(ref)
}

//export uLChangeURLCallback4EC32B80
func uLChangeURLCallback4EC32B80(cuser_data unsafe.Pointer, ccaller C.ULView, curl C.ULString) {
	if uLChangeURLCallback4EC32B80Func != nil {
		user_data4ec32b80 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller4ec32b80 := *(*ULView)(unsafe.Pointer(&ccaller))
		url4ec32b80 := *(*ULString)(unsafe.Pointer(&curl))
		uLChangeURLCallback4EC32B80Func(user_data4ec32b80, caller4ec32b80, url4ec32b80)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeURLCallback4EC32B80Func ULChangeURLCallback

func (x ULChangeTooltipCallback) PassRef() (ref *C.ULChangeTooltipCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTooltipCallback12CA407Func == nil {
		uLChangeTooltipCallback12CA407Func = x
	}
	return (*C.ULChangeTooltipCallback)(C.ULChangeTooltipCallback_12ca407), nil
}

func (x ULChangeTooltipCallback) PassValue() (ref C.ULChangeTooltipCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeTooltipCallback12CA407Func == nil {
		uLChangeTooltipCallback12CA407Func = x
	}
	return (C.ULChangeTooltipCallback)(C.ULChangeTooltipCallback_12ca407), nil
}

func NewULChangeTooltipCallbackRef(ref unsafe.Pointer) *ULChangeTooltipCallback {
	return (*ULChangeTooltipCallback)(ref)
}

//export uLChangeTooltipCallback12CA407
func uLChangeTooltipCallback12CA407(cuser_data unsafe.Pointer, ccaller C.ULView, ctooltip C.ULString) {
	if uLChangeTooltipCallback12CA407Func != nil {
		user_data12ca407 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller12ca407 := *(*ULView)(unsafe.Pointer(&ccaller))
		tooltip12ca407 := *(*ULString)(unsafe.Pointer(&ctooltip))
		uLChangeTooltipCallback12CA407Func(user_data12ca407, caller12ca407, tooltip12ca407)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeTooltipCallback12CA407Func ULChangeTooltipCallback

func (x ULChangeCursorCallback) PassRef() (ref *C.ULChangeCursorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeCursorCallback1A7011DFFunc == nil {
		uLChangeCursorCallback1A7011DFFunc = x
	}
	return (*C.ULChangeCursorCallback)(C.ULChangeCursorCallback_1a7011df), nil
}

func (x ULChangeCursorCallback) PassValue() (ref C.ULChangeCursorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLChangeCursorCallback1A7011DFFunc == nil {
		uLChangeCursorCallback1A7011DFFunc = x
	}
	return (C.ULChangeCursorCallback)(C.ULChangeCursorCallback_1a7011df), nil
}

func NewULChangeCursorCallbackRef(ref unsafe.Pointer) *ULChangeCursorCallback {
	return (*ULChangeCursorCallback)(ref)
}

//export uLChangeCursorCallback1A7011DF
func uLChangeCursorCallback1A7011DF(cuser_data unsafe.Pointer, ccaller C.ULView, ccursor C.ULCursor) {
	if uLChangeCursorCallback1A7011DFFunc != nil {
		user_data1a7011df := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller1a7011df := *(*ULView)(unsafe.Pointer(&ccaller))
		cursor1a7011df := (ULCursor)(ccursor)
		uLChangeCursorCallback1A7011DFFunc(user_data1a7011df, caller1a7011df, cursor1a7011df)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLChangeCursorCallback1A7011DFFunc ULChangeCursorCallback

func (x ULAddConsoleMessageCallback) PassRef() (ref *C.ULAddConsoleMessageCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLAddConsoleMessageCallback44B8DD01Func == nil {
		uLAddConsoleMessageCallback44B8DD01Func = x
	}
	return (*C.ULAddConsoleMessageCallback)(C.ULAddConsoleMessageCallback_44b8dd01), nil
}

func (x ULAddConsoleMessageCallback) PassValue() (ref C.ULAddConsoleMessageCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLAddConsoleMessageCallback44B8DD01Func == nil {
		uLAddConsoleMessageCallback44B8DD01Func = x
	}
	return (C.ULAddConsoleMessageCallback)(C.ULAddConsoleMessageCallback_44b8dd01), nil
}

func NewULAddConsoleMessageCallbackRef(ref unsafe.Pointer) *ULAddConsoleMessageCallback {
	return (*ULAddConsoleMessageCallback)(ref)
}

//export uLAddConsoleMessageCallback44B8DD01
func uLAddConsoleMessageCallback44B8DD01(cuser_data unsafe.Pointer, ccaller C.ULView, csource C.ULMessageSource, clevel C.ULMessageLevel, cmessage C.ULString, cline_number C.uint, ccolumn_number C.uint, csource_id C.ULString) {
	if uLAddConsoleMessageCallback44B8DD01Func != nil {
		user_data44b8dd01 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller44b8dd01 := *(*ULView)(unsafe.Pointer(&ccaller))
		source44b8dd01 := (ULMessageSource)(csource)
		level44b8dd01 := (ULMessageLevel)(clevel)
		message44b8dd01 := *(*ULString)(unsafe.Pointer(&cmessage))
		line_number44b8dd01 := (uint32)(cline_number)
		column_number44b8dd01 := (uint32)(ccolumn_number)
		source_id44b8dd01 := *(*ULString)(unsafe.Pointer(&csource_id))
		uLAddConsoleMessageCallback44B8DD01Func(user_data44b8dd01, caller44b8dd01, source44b8dd01, level44b8dd01, message44b8dd01, line_number44b8dd01, column_number44b8dd01, source_id44b8dd01)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLAddConsoleMessageCallback44B8DD01Func ULAddConsoleMessageCallback

func (x ULBeginLoadingCallback) PassRef() (ref *C.ULBeginLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLBeginLoadingCallback70D8C0ADFunc == nil {
		uLBeginLoadingCallback70D8C0ADFunc = x
	}
	return (*C.ULBeginLoadingCallback)(C.ULBeginLoadingCallback_70d8c0ad), nil
}

func (x ULBeginLoadingCallback) PassValue() (ref C.ULBeginLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLBeginLoadingCallback70D8C0ADFunc == nil {
		uLBeginLoadingCallback70D8C0ADFunc = x
	}
	return (C.ULBeginLoadingCallback)(C.ULBeginLoadingCallback_70d8c0ad), nil
}

func NewULBeginLoadingCallbackRef(ref unsafe.Pointer) *ULBeginLoadingCallback {
	return (*ULBeginLoadingCallback)(ref)
}

//export uLBeginLoadingCallback70D8C0AD
func uLBeginLoadingCallback70D8C0AD(cuser_data unsafe.Pointer, ccaller C.ULView) {
	if uLBeginLoadingCallback70D8C0ADFunc != nil {
		user_data70d8c0ad := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller70d8c0ad := *(*ULView)(unsafe.Pointer(&ccaller))
		uLBeginLoadingCallback70D8C0ADFunc(user_data70d8c0ad, caller70d8c0ad)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLBeginLoadingCallback70D8C0ADFunc ULBeginLoadingCallback

func (x ULFinishLoadingCallback) PassRef() (ref *C.ULFinishLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFinishLoadingCallback1ED4ECAEFunc == nil {
		uLFinishLoadingCallback1ED4ECAEFunc = x
	}
	return (*C.ULFinishLoadingCallback)(C.ULFinishLoadingCallback_1ed4ecae), nil
}

func (x ULFinishLoadingCallback) PassValue() (ref C.ULFinishLoadingCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLFinishLoadingCallback1ED4ECAEFunc == nil {
		uLFinishLoadingCallback1ED4ECAEFunc = x
	}
	return (C.ULFinishLoadingCallback)(C.ULFinishLoadingCallback_1ed4ecae), nil
}

func NewULFinishLoadingCallbackRef(ref unsafe.Pointer) *ULFinishLoadingCallback {
	return (*ULFinishLoadingCallback)(ref)
}

//export uLFinishLoadingCallback1ED4ECAE
func uLFinishLoadingCallback1ED4ECAE(cuser_data unsafe.Pointer, ccaller C.ULView) {
	if uLFinishLoadingCallback1ED4ECAEFunc != nil {
		user_data1ed4ecae := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller1ed4ecae := *(*ULView)(unsafe.Pointer(&ccaller))
		uLFinishLoadingCallback1ED4ECAEFunc(user_data1ed4ecae, caller1ed4ecae)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLFinishLoadingCallback1ED4ECAEFunc ULFinishLoadingCallback

func (x ULUpdateHistoryCallback) PassRef() (ref *C.ULUpdateHistoryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateHistoryCallback6E105364Func == nil {
		uLUpdateHistoryCallback6E105364Func = x
	}
	return (*C.ULUpdateHistoryCallback)(C.ULUpdateHistoryCallback_6e105364), nil
}

func (x ULUpdateHistoryCallback) PassValue() (ref C.ULUpdateHistoryCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLUpdateHistoryCallback6E105364Func == nil {
		uLUpdateHistoryCallback6E105364Func = x
	}
	return (C.ULUpdateHistoryCallback)(C.ULUpdateHistoryCallback_6e105364), nil
}

func NewULUpdateHistoryCallbackRef(ref unsafe.Pointer) *ULUpdateHistoryCallback {
	return (*ULUpdateHistoryCallback)(ref)
}

//export uLUpdateHistoryCallback6E105364
func uLUpdateHistoryCallback6E105364(cuser_data unsafe.Pointer, ccaller C.ULView) {
	if uLUpdateHistoryCallback6E105364Func != nil {
		user_data6e105364 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller6e105364 := *(*ULView)(unsafe.Pointer(&ccaller))
		uLUpdateHistoryCallback6E105364Func(user_data6e105364, caller6e105364)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLUpdateHistoryCallback6E105364Func ULUpdateHistoryCallback

func (x ULDOMReadyCallback) PassRef() (ref *C.ULDOMReadyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLDOMReadyCallback6432C207Func == nil {
		uLDOMReadyCallback6432C207Func = x
	}
	return (*C.ULDOMReadyCallback)(C.ULDOMReadyCallback_6432c207), nil
}

func (x ULDOMReadyCallback) PassValue() (ref C.ULDOMReadyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if uLDOMReadyCallback6432C207Func == nil {
		uLDOMReadyCallback6432C207Func = x
	}
	return (C.ULDOMReadyCallback)(C.ULDOMReadyCallback_6432c207), nil
}

func NewULDOMReadyCallbackRef(ref unsafe.Pointer) *ULDOMReadyCallback {
	return (*ULDOMReadyCallback)(ref)
}

//export uLDOMReadyCallback6432C207
func uLDOMReadyCallback6432C207(cuser_data unsafe.Pointer, ccaller C.ULView) {
	if uLDOMReadyCallback6432C207Func != nil {
		user_data6432c207 := (unsafe.Pointer)(unsafe.Pointer(cuser_data))
		caller6432c207 := *(*ULView)(unsafe.Pointer(&ccaller))
		uLDOMReadyCallback6432C207Func(user_data6432c207, caller6432c207)
		return
	}
	panic("callback func has not been set (race?)")
}

var uLDOMReadyCallback6432C207Func ULDOMReadyCallback

func (x JSTypedArrayBytesDeallocator) PassRef() (ref *C.JSTypedArrayBytesDeallocator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSTypedArrayBytesDeallocator68D51F83Func == nil {
		jSTypedArrayBytesDeallocator68D51F83Func = x
	}
	return (*C.JSTypedArrayBytesDeallocator)(C.JSTypedArrayBytesDeallocator_68d51f83), nil
}

func (x JSTypedArrayBytesDeallocator) PassValue() (ref C.JSTypedArrayBytesDeallocator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSTypedArrayBytesDeallocator68D51F83Func == nil {
		jSTypedArrayBytesDeallocator68D51F83Func = x
	}
	return (C.JSTypedArrayBytesDeallocator)(C.JSTypedArrayBytesDeallocator_68d51f83), nil
}

func NewJSTypedArrayBytesDeallocatorRef(ref unsafe.Pointer) *JSTypedArrayBytesDeallocator {
	return (*JSTypedArrayBytesDeallocator)(ref)
}

//export jSTypedArrayBytesDeallocator68D51F83
func jSTypedArrayBytesDeallocator68D51F83(cbytes unsafe.Pointer, cdeallocatorContext unsafe.Pointer) {
	if jSTypedArrayBytesDeallocator68D51F83Func != nil {
		bytes68d51f83 := (unsafe.Pointer)(unsafe.Pointer(cbytes))
		deallocatorContext68d51f83 := (unsafe.Pointer)(unsafe.Pointer(cdeallocatorContext))
		jSTypedArrayBytesDeallocator68D51F83Func(bytes68d51f83, deallocatorContext68d51f83)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSTypedArrayBytesDeallocator68D51F83Func JSTypedArrayBytesDeallocator

func (x JSObjectInitializeCallback) PassRef() (ref *C.JSObjectInitializeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectInitializeCallback5793B16Func == nil {
		jSObjectInitializeCallback5793B16Func = x
	}
	return (*C.JSObjectInitializeCallback)(C.JSObjectInitializeCallback_5793b16), nil
}

func (x JSObjectInitializeCallback) PassValue() (ref C.JSObjectInitializeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectInitializeCallback5793B16Func == nil {
		jSObjectInitializeCallback5793B16Func = x
	}
	return (C.JSObjectInitializeCallback)(C.JSObjectInitializeCallback_5793b16), nil
}

func NewJSObjectInitializeCallbackRef(ref unsafe.Pointer) *JSObjectInitializeCallback {
	return (*JSObjectInitializeCallback)(ref)
}

//export jSObjectInitializeCallback5793B16
func jSObjectInitializeCallback5793B16(cctx C.JSContextRef, cobject C.JSObjectRef) {
	if jSObjectInitializeCallback5793B16Func != nil {
		ctx5793b16 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		object5793b16 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		jSObjectInitializeCallback5793B16Func(ctx5793b16, object5793b16)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectInitializeCallback5793B16Func JSObjectInitializeCallback

func (x JSObjectFinalizeCallback) PassRef() (ref *C.JSObjectFinalizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectFinalizeCallback93DA0AEAFunc == nil {
		jSObjectFinalizeCallback93DA0AEAFunc = x
	}
	return (*C.JSObjectFinalizeCallback)(C.JSObjectFinalizeCallback_93da0aea), nil
}

func (x JSObjectFinalizeCallback) PassValue() (ref C.JSObjectFinalizeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectFinalizeCallback93DA0AEAFunc == nil {
		jSObjectFinalizeCallback93DA0AEAFunc = x
	}
	return (C.JSObjectFinalizeCallback)(C.JSObjectFinalizeCallback_93da0aea), nil
}

func NewJSObjectFinalizeCallbackRef(ref unsafe.Pointer) *JSObjectFinalizeCallback {
	return (*JSObjectFinalizeCallback)(ref)
}

//export jSObjectFinalizeCallback93DA0AEA
func jSObjectFinalizeCallback93DA0AEA(cobject C.JSObjectRef) {
	if jSObjectFinalizeCallback93DA0AEAFunc != nil {
		object93da0aea := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		jSObjectFinalizeCallback93DA0AEAFunc(object93da0aea)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectFinalizeCallback93DA0AEAFunc JSObjectFinalizeCallback

func (x JSObjectHasPropertyCallback) PassRef() (ref *C.JSObjectHasPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasPropertyCallback340BFA95Func == nil {
		jSObjectHasPropertyCallback340BFA95Func = x
	}
	return (*C.JSObjectHasPropertyCallback)(C.JSObjectHasPropertyCallback_340bfa95), nil
}

func (x JSObjectHasPropertyCallback) PassValue() (ref C.JSObjectHasPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasPropertyCallback340BFA95Func == nil {
		jSObjectHasPropertyCallback340BFA95Func = x
	}
	return (C.JSObjectHasPropertyCallback)(C.JSObjectHasPropertyCallback_340bfa95), nil
}

func NewJSObjectHasPropertyCallbackRef(ref unsafe.Pointer) *JSObjectHasPropertyCallback {
	return (*JSObjectHasPropertyCallback)(ref)
}

//export jSObjectHasPropertyCallback340BFA95
func jSObjectHasPropertyCallback340BFA95(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef) C._Bool {
	if jSObjectHasPropertyCallback340BFA95Func != nil {
		ctx340bfa95 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		object340bfa95 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyName340bfa95 := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		ret340bfa95 := jSObjectHasPropertyCallback340BFA95Func(ctx340bfa95, object340bfa95, propertyName340bfa95)
		ret, _ := (C._Bool)(ret340bfa95), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectHasPropertyCallback340BFA95Func JSObjectHasPropertyCallback

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x JSObjectGetPropertyCallback) PassRef() (ref *C.JSObjectGetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyCallback5CAEC716Func == nil {
		jSObjectGetPropertyCallback5CAEC716Func = x
	}
	return (*C.JSObjectGetPropertyCallback)(C.JSObjectGetPropertyCallback_5caec716), nil
}

func (x JSObjectGetPropertyCallback) PassValue() (ref C.JSObjectGetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyCallback5CAEC716Func == nil {
		jSObjectGetPropertyCallback5CAEC716Func = x
	}
	return (C.JSObjectGetPropertyCallback)(C.JSObjectGetPropertyCallback_5caec716), nil
}

func NewJSObjectGetPropertyCallbackRef(ref unsafe.Pointer) *JSObjectGetPropertyCallback {
	return (*JSObjectGetPropertyCallback)(ref)
}

//export jSObjectGetPropertyCallback5CAEC716
func jSObjectGetPropertyCallback5CAEC716(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectGetPropertyCallback5CAEC716Func != nil {
		ctx5caec716 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		object5caec716 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyName5caec716 := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		var exception5caec716 []JSValueRef
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&exception5caec716))
		hxfc4425b.Data = unsafe.Pointer(cexception)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		ret5caec716 := jSObjectGetPropertyCallback5CAEC716Func(ctx5caec716, object5caec716, propertyName5caec716, exception5caec716)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret5caec716)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectGetPropertyCallback5CAEC716Func JSObjectGetPropertyCallback

func (x JSObjectSetPropertyCallback) PassRef() (ref *C.JSObjectSetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectSetPropertyCallbackA684F1FEFunc == nil {
		jSObjectSetPropertyCallbackA684F1FEFunc = x
	}
	return (*C.JSObjectSetPropertyCallback)(C.JSObjectSetPropertyCallback_a684f1fe), nil
}

func (x JSObjectSetPropertyCallback) PassValue() (ref C.JSObjectSetPropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectSetPropertyCallbackA684F1FEFunc == nil {
		jSObjectSetPropertyCallbackA684F1FEFunc = x
	}
	return (C.JSObjectSetPropertyCallback)(C.JSObjectSetPropertyCallback_a684f1fe), nil
}

func NewJSObjectSetPropertyCallbackRef(ref unsafe.Pointer) *JSObjectSetPropertyCallback {
	return (*JSObjectSetPropertyCallback)(ref)
}

//export jSObjectSetPropertyCallbackA684F1FE
func jSObjectSetPropertyCallbackA684F1FE(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cvalue C.JSValueRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectSetPropertyCallbackA684F1FEFunc != nil {
		ctxa684f1fe := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objecta684f1fe := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamea684f1fe := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		valuea684f1fe := *(*JSValueRef)(unsafe.Pointer(&cvalue))
		var exceptiona684f1fe []JSValueRef
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&exceptiona684f1fe))
		hxf95e7c8.Data = unsafe.Pointer(cexception)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		reta684f1fe := jSObjectSetPropertyCallbackA684F1FEFunc(ctxa684f1fe, objecta684f1fe, propertyNamea684f1fe, valuea684f1fe, exceptiona684f1fe)
		ret, _ := (C._Bool)(reta684f1fe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectSetPropertyCallbackA684F1FEFunc JSObjectSetPropertyCallback

func (x JSObjectDeletePropertyCallback) PassRef() (ref *C.JSObjectDeletePropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectDeletePropertyCallbackB0108EBEFunc == nil {
		jSObjectDeletePropertyCallbackB0108EBEFunc = x
	}
	return (*C.JSObjectDeletePropertyCallback)(C.JSObjectDeletePropertyCallback_b0108ebe), nil
}

func (x JSObjectDeletePropertyCallback) PassValue() (ref C.JSObjectDeletePropertyCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectDeletePropertyCallbackB0108EBEFunc == nil {
		jSObjectDeletePropertyCallbackB0108EBEFunc = x
	}
	return (C.JSObjectDeletePropertyCallback)(C.JSObjectDeletePropertyCallback_b0108ebe), nil
}

func NewJSObjectDeletePropertyCallbackRef(ref unsafe.Pointer) *JSObjectDeletePropertyCallback {
	return (*JSObjectDeletePropertyCallback)(ref)
}

//export jSObjectDeletePropertyCallbackB0108EBE
func jSObjectDeletePropertyCallbackB0108EBE(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyName C.JSStringRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectDeletePropertyCallbackB0108EBEFunc != nil {
		ctxb0108ebe := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objectb0108ebe := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNameb0108ebe := *(*JSStringRef)(unsafe.Pointer(&cpropertyName))
		var exceptionb0108ebe []JSValueRef
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&exceptionb0108ebe))
		hxff2234b.Data = unsafe.Pointer(cexception)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		retb0108ebe := jSObjectDeletePropertyCallbackB0108EBEFunc(ctxb0108ebe, objectb0108ebe, propertyNameb0108ebe, exceptionb0108ebe)
		ret, _ := (C._Bool)(retb0108ebe), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectDeletePropertyCallbackB0108EBEFunc JSObjectDeletePropertyCallback

func (x JSObjectGetPropertyNamesCallback) PassRef() (ref *C.JSObjectGetPropertyNamesCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyNamesCallbackE77D2329Func == nil {
		jSObjectGetPropertyNamesCallbackE77D2329Func = x
	}
	return (*C.JSObjectGetPropertyNamesCallback)(C.JSObjectGetPropertyNamesCallback_e77d2329), nil
}

func (x JSObjectGetPropertyNamesCallback) PassValue() (ref C.JSObjectGetPropertyNamesCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectGetPropertyNamesCallbackE77D2329Func == nil {
		jSObjectGetPropertyNamesCallbackE77D2329Func = x
	}
	return (C.JSObjectGetPropertyNamesCallback)(C.JSObjectGetPropertyNamesCallback_e77d2329), nil
}

func NewJSObjectGetPropertyNamesCallbackRef(ref unsafe.Pointer) *JSObjectGetPropertyNamesCallback {
	return (*JSObjectGetPropertyNamesCallback)(ref)
}

//export jSObjectGetPropertyNamesCallbackE77D2329
func jSObjectGetPropertyNamesCallbackE77D2329(cctx C.JSContextRef, cobject C.JSObjectRef, cpropertyNames C.JSPropertyNameAccumulatorRef) {
	if jSObjectGetPropertyNamesCallbackE77D2329Func != nil {
		ctxe77d2329 := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objecte77d2329 := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		propertyNamese77d2329 := *(*JSPropertyNameAccumulatorRef)(unsafe.Pointer(&cpropertyNames))
		jSObjectGetPropertyNamesCallbackE77D2329Func(ctxe77d2329, objecte77d2329, propertyNamese77d2329)
		return
	}
	panic("callback func has not been set (race?)")
}

var jSObjectGetPropertyNamesCallbackE77D2329Func JSObjectGetPropertyNamesCallback

func (x JSObjectCallAsFunctionCallback) PassRef() (ref *C.JSObjectCallAsFunctionCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsFunctionCallback89F9469BFunc == nil {
		jSObjectCallAsFunctionCallback89F9469BFunc = x
	}
	return (*C.JSObjectCallAsFunctionCallback)(C.JSObjectCallAsFunctionCallback_89f9469b), nil
}

func (x JSObjectCallAsFunctionCallback) PassValue() (ref C.JSObjectCallAsFunctionCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsFunctionCallback89F9469BFunc == nil {
		jSObjectCallAsFunctionCallback89F9469BFunc = x
	}
	return (C.JSObjectCallAsFunctionCallback)(C.JSObjectCallAsFunctionCallback_89f9469b), nil
}

func NewJSObjectCallAsFunctionCallbackRef(ref unsafe.Pointer) *JSObjectCallAsFunctionCallback {
	return (*JSObjectCallAsFunctionCallback)(ref)
}

//export jSObjectCallAsFunctionCallback89F9469B
func jSObjectCallAsFunctionCallback89F9469B(cctx C.JSContextRef, cfunction C.JSObjectRef, cthisObject C.JSObjectRef, cargumentCount C.size_t, carguments *C.JSValueRef, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectCallAsFunctionCallback89F9469BFunc != nil {
		ctx89f9469b := *(*JSContextRef)(unsafe.Pointer(&cctx))
		function89f9469b := *(*JSObjectRef)(unsafe.Pointer(&cfunction))
		thisObject89f9469b := *(*JSObjectRef)(unsafe.Pointer(&cthisObject))
		argumentCount89f9469b := (uint)(cargumentCount)
		var arguments89f9469b []JSValueRef
		hxff73280 := (*sliceHeader)(unsafe.Pointer(&arguments89f9469b))
		hxff73280.Data = unsafe.Pointer(carguments)
		hxff73280.Cap = 0x7fffffff
		hxff73280.Len = int(argumentCount89f9469b)

		var exception89f9469b []JSValueRef
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&exception89f9469b))
		hxfa9955c.Data = unsafe.Pointer(cexception)
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		ret89f9469b := jSObjectCallAsFunctionCallback89F9469BFunc(ctx89f9469b, function89f9469b, thisObject89f9469b, argumentCount89f9469b, arguments89f9469b, exception89f9469b)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&ret89f9469b)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectCallAsFunctionCallback89F9469BFunc JSObjectCallAsFunctionCallback

func (x JSObjectCallAsConstructorCallback) PassRef() (ref *C.JSObjectCallAsConstructorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsConstructorCallback45F4B71FFunc == nil {
		jSObjectCallAsConstructorCallback45F4B71FFunc = x
	}
	return (*C.JSObjectCallAsConstructorCallback)(C.JSObjectCallAsConstructorCallback_45f4b71f), nil
}

func (x JSObjectCallAsConstructorCallback) PassValue() (ref C.JSObjectCallAsConstructorCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectCallAsConstructorCallback45F4B71FFunc == nil {
		jSObjectCallAsConstructorCallback45F4B71FFunc = x
	}
	return (C.JSObjectCallAsConstructorCallback)(C.JSObjectCallAsConstructorCallback_45f4b71f), nil
}

func NewJSObjectCallAsConstructorCallbackRef(ref unsafe.Pointer) *JSObjectCallAsConstructorCallback {
	return (*JSObjectCallAsConstructorCallback)(ref)
}

//export jSObjectCallAsConstructorCallback45F4B71F
func jSObjectCallAsConstructorCallback45F4B71F(cctx C.JSContextRef, cconstructor C.JSObjectRef, cargumentCount C.size_t, carguments *C.JSValueRef, cexception *C.JSValueRef) C.JSObjectRef {
	if jSObjectCallAsConstructorCallback45F4B71FFunc != nil {
		ctx45f4b71f := *(*JSContextRef)(unsafe.Pointer(&cctx))
		constructor45f4b71f := *(*JSObjectRef)(unsafe.Pointer(&cconstructor))
		argumentCount45f4b71f := (uint)(cargumentCount)
		var arguments45f4b71f []JSValueRef
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&arguments45f4b71f))
		hxfa3f05c.Data = unsafe.Pointer(carguments)
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		var exception45f4b71f []JSValueRef
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&exception45f4b71f))
		hxf0d18b7.Data = unsafe.Pointer(cexception)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		ret45f4b71f := jSObjectCallAsConstructorCallback45F4B71FFunc(ctx45f4b71f, constructor45f4b71f, argumentCount45f4b71f, arguments45f4b71f, exception45f4b71f)
		ret, _ := *(*C.JSObjectRef)(unsafe.Pointer(&ret45f4b71f)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectCallAsConstructorCallback45F4B71FFunc JSObjectCallAsConstructorCallback

func (x JSObjectHasInstanceCallback) PassRef() (ref *C.JSObjectHasInstanceCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasInstanceCallbackAA527D2EFunc == nil {
		jSObjectHasInstanceCallbackAA527D2EFunc = x
	}
	return (*C.JSObjectHasInstanceCallback)(C.JSObjectHasInstanceCallback_aa527d2e), nil
}

func (x JSObjectHasInstanceCallback) PassValue() (ref C.JSObjectHasInstanceCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectHasInstanceCallbackAA527D2EFunc == nil {
		jSObjectHasInstanceCallbackAA527D2EFunc = x
	}
	return (C.JSObjectHasInstanceCallback)(C.JSObjectHasInstanceCallback_aa527d2e), nil
}

func NewJSObjectHasInstanceCallbackRef(ref unsafe.Pointer) *JSObjectHasInstanceCallback {
	return (*JSObjectHasInstanceCallback)(ref)
}

//export jSObjectHasInstanceCallbackAA527D2E
func jSObjectHasInstanceCallbackAA527D2E(cctx C.JSContextRef, cconstructor C.JSObjectRef, cpossibleInstance C.JSValueRef, cexception *C.JSValueRef) C._Bool {
	if jSObjectHasInstanceCallbackAA527D2EFunc != nil {
		ctxaa527d2e := *(*JSContextRef)(unsafe.Pointer(&cctx))
		constructoraa527d2e := *(*JSObjectRef)(unsafe.Pointer(&cconstructor))
		possibleInstanceaa527d2e := *(*JSValueRef)(unsafe.Pointer(&cpossibleInstance))
		var exceptionaa527d2e []JSValueRef
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&exceptionaa527d2e))
		hxf2fab0d.Data = unsafe.Pointer(cexception)
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?

		retaa527d2e := jSObjectHasInstanceCallbackAA527D2EFunc(ctxaa527d2e, constructoraa527d2e, possibleInstanceaa527d2e, exceptionaa527d2e)
		ret, _ := (C._Bool)(retaa527d2e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectHasInstanceCallbackAA527D2EFunc JSObjectHasInstanceCallback

func (x JSObjectConvertToTypeCallback) PassRef() (ref *C.JSObjectConvertToTypeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectConvertToTypeCallbackD379D61CFunc == nil {
		jSObjectConvertToTypeCallbackD379D61CFunc = x
	}
	return (*C.JSObjectConvertToTypeCallback)(C.JSObjectConvertToTypeCallback_d379d61c), nil
}

func (x JSObjectConvertToTypeCallback) PassValue() (ref C.JSObjectConvertToTypeCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if jSObjectConvertToTypeCallbackD379D61CFunc == nil {
		jSObjectConvertToTypeCallbackD379D61CFunc = x
	}
	return (C.JSObjectConvertToTypeCallback)(C.JSObjectConvertToTypeCallback_d379d61c), nil
}

func NewJSObjectConvertToTypeCallbackRef(ref unsafe.Pointer) *JSObjectConvertToTypeCallback {
	return (*JSObjectConvertToTypeCallback)(ref)
}

//export jSObjectConvertToTypeCallbackD379D61C
func jSObjectConvertToTypeCallbackD379D61C(cctx C.JSContextRef, cobject C.JSObjectRef, c_type C.JSType, cexception *C.JSValueRef) C.JSValueRef {
	if jSObjectConvertToTypeCallbackD379D61CFunc != nil {
		ctxd379d61c := *(*JSContextRef)(unsafe.Pointer(&cctx))
		objectd379d61c := *(*JSObjectRef)(unsafe.Pointer(&cobject))
		_typed379d61c := (JSType)(c_type)
		var exceptiond379d61c []JSValueRef
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&exceptiond379d61c))
		hxf69fe70.Data = unsafe.Pointer(cexception)
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?

		retd379d61c := jSObjectConvertToTypeCallbackD379D61CFunc(ctxd379d61c, objectd379d61c, _typed379d61c, exceptiond379d61c)
		ret, _ := *(*C.JSValueRef)(unsafe.Pointer(&retd379d61c)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var jSObjectConvertToTypeCallbackD379D61CFunc JSObjectConvertToTypeCallback

// allocJSStaticValueMemory allocates memory for type C.JSStaticValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStaticValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStaticValueValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJSStaticValueValue = unsafe.Sizeof([1]C.JSStaticValue{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSStaticValue) Ref() *C.JSStaticValue {
	if x == nil {
		return nil
	}
	return x.ref34655956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSStaticValue) Free() {
	if x != nil && x.allocs34655956 != nil {
		x.allocs34655956.(*cgoAllocMap).Free()
		x.ref34655956 = nil
	}
}

// NewJSStaticValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSStaticValueRef(ref unsafe.Pointer) *JSStaticValue {
	if ref == nil {
		return nil
	}
	obj := new(JSStaticValue)
	obj.ref34655956 = (*C.JSStaticValue)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSStaticValue) PassRef() (*C.JSStaticValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34655956 != nil {
		return x.ref34655956, nil
	}
	mem34655956 := allocJSStaticValueMemory(1)
	ref34655956 := (*C.JSStaticValue)(mem34655956)
	allocs34655956 := new(cgoAllocMap)
	allocs34655956.Add(mem34655956)

	var cname_allocs *cgoAllocMap
	ref34655956.name, cname_allocs = unpackPCharString(x.Name)
	allocs34655956.Borrow(cname_allocs)

	var cgetProperty_allocs *cgoAllocMap
	ref34655956.getProperty, cgetProperty_allocs = x.GetProperty.PassValue()
	allocs34655956.Borrow(cgetProperty_allocs)

	var csetProperty_allocs *cgoAllocMap
	ref34655956.setProperty, csetProperty_allocs = x.SetProperty.PassValue()
	allocs34655956.Borrow(csetProperty_allocs)

	var cattributes_allocs *cgoAllocMap
	ref34655956.attributes, cattributes_allocs = (C.JSPropertyAttributes)(x.Attributes), cgoAllocsUnknown
	allocs34655956.Borrow(cattributes_allocs)

	x.ref34655956 = ref34655956
	x.allocs34655956 = allocs34655956
	return ref34655956, allocs34655956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSStaticValue) PassValue() (C.JSStaticValue, *cgoAllocMap) {
	if x.ref34655956 != nil {
		return *x.ref34655956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSStaticValue) Deref() {
	if x.ref34655956 == nil {
		return
	}
	x.Name = packPCharString(x.ref34655956.name)
	x.GetProperty = *NewJSObjectGetPropertyCallbackRef(unsafe.Pointer(&x.ref34655956.getProperty))
	x.SetProperty = *NewJSObjectSetPropertyCallbackRef(unsafe.Pointer(&x.ref34655956.setProperty))
	x.Attributes = (JSPropertyAttributes)(x.ref34655956.attributes)
}

// allocJSStaticFunctionMemory allocates memory for type C.JSStaticFunction in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSStaticFunctionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSStaticFunctionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJSStaticFunctionValue = unsafe.Sizeof([1]C.JSStaticFunction{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSStaticFunction) Ref() *C.JSStaticFunction {
	if x == nil {
		return nil
	}
	return x.ref6b5f4953
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSStaticFunction) Free() {
	if x != nil && x.allocs6b5f4953 != nil {
		x.allocs6b5f4953.(*cgoAllocMap).Free()
		x.ref6b5f4953 = nil
	}
}

// NewJSStaticFunctionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSStaticFunctionRef(ref unsafe.Pointer) *JSStaticFunction {
	if ref == nil {
		return nil
	}
	obj := new(JSStaticFunction)
	obj.ref6b5f4953 = (*C.JSStaticFunction)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSStaticFunction) PassRef() (*C.JSStaticFunction, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b5f4953 != nil {
		return x.ref6b5f4953, nil
	}
	mem6b5f4953 := allocJSStaticFunctionMemory(1)
	ref6b5f4953 := (*C.JSStaticFunction)(mem6b5f4953)
	allocs6b5f4953 := new(cgoAllocMap)
	allocs6b5f4953.Add(mem6b5f4953)

	var cname_allocs *cgoAllocMap
	ref6b5f4953.name, cname_allocs = unpackPCharString(x.Name)
	allocs6b5f4953.Borrow(cname_allocs)

	var ccallAsFunction_allocs *cgoAllocMap
	ref6b5f4953.callAsFunction, ccallAsFunction_allocs = x.CallAsFunction.PassValue()
	allocs6b5f4953.Borrow(ccallAsFunction_allocs)

	var cattributes_allocs *cgoAllocMap
	ref6b5f4953.attributes, cattributes_allocs = (C.JSPropertyAttributes)(x.Attributes), cgoAllocsUnknown
	allocs6b5f4953.Borrow(cattributes_allocs)

	x.ref6b5f4953 = ref6b5f4953
	x.allocs6b5f4953 = allocs6b5f4953
	return ref6b5f4953, allocs6b5f4953

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSStaticFunction) PassValue() (C.JSStaticFunction, *cgoAllocMap) {
	if x.ref6b5f4953 != nil {
		return *x.ref6b5f4953, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSStaticFunction) Deref() {
	if x.ref6b5f4953 == nil {
		return
	}
	x.Name = packPCharString(x.ref6b5f4953.name)
	x.CallAsFunction = *NewJSObjectCallAsFunctionCallbackRef(unsafe.Pointer(&x.ref6b5f4953.callAsFunction))
	x.Attributes = (JSPropertyAttributes)(x.ref6b5f4953.attributes)
}

// allocJSClassDefinitionMemory allocates memory for type C.JSClassDefinition in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJSClassDefinitionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJSClassDefinitionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJSClassDefinitionValue = unsafe.Sizeof([1]C.JSClassDefinition{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSJSStaticValue transforms a sliced Go data structure into plain C format.
func unpackSJSStaticValue(x []JSStaticValue) (unpacked *C.JSStaticValue, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.JSStaticValue) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocJSStaticValueMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.JSStaticValue)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.JSStaticValue)(h.Data)
	return
}

// unpackSJSStaticFunction transforms a sliced Go data structure into plain C format.
func unpackSJSStaticFunction(x []JSStaticFunction) (unpacked *C.JSStaticFunction, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.JSStaticFunction) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocJSStaticFunctionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.JSStaticFunction)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.JSStaticFunction)(h.Data)
	return
}

// packSJSStaticValue reads sliced Go data structure out from plain C format.
func packSJSStaticValue(v []JSStaticValue, ptr0 *C.JSStaticValue) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfJSStaticValueValue]C.JSStaticValue)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewJSStaticValueRef(unsafe.Pointer(&ptr1))
	}
}

// packSJSStaticFunction reads sliced Go data structure out from plain C format.
func packSJSStaticFunction(v []JSStaticFunction, ptr0 *C.JSStaticFunction) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfJSStaticFunctionValue]C.JSStaticFunction)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewJSStaticFunctionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JSClassDefinition) Ref() *C.JSClassDefinition {
	if x == nil {
		return nil
	}
	return x.ref192c18d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JSClassDefinition) Free() {
	if x != nil && x.allocs192c18d5 != nil {
		x.allocs192c18d5.(*cgoAllocMap).Free()
		x.ref192c18d5 = nil
	}
}

// NewJSClassDefinitionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJSClassDefinitionRef(ref unsafe.Pointer) *JSClassDefinition {
	if ref == nil {
		return nil
	}
	obj := new(JSClassDefinition)
	obj.ref192c18d5 = (*C.JSClassDefinition)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JSClassDefinition) PassRef() (*C.JSClassDefinition, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref192c18d5 != nil {
		return x.ref192c18d5, nil
	}
	mem192c18d5 := allocJSClassDefinitionMemory(1)
	ref192c18d5 := (*C.JSClassDefinition)(mem192c18d5)
	allocs192c18d5 := new(cgoAllocMap)
	allocs192c18d5.Add(mem192c18d5)

	var cversion_allocs *cgoAllocMap
	ref192c18d5.version, cversion_allocs = (C.int)(x.Version), cgoAllocsUnknown
	allocs192c18d5.Borrow(cversion_allocs)

	var cattributes_allocs *cgoAllocMap
	ref192c18d5.attributes, cattributes_allocs = (C.JSClassAttributes)(x.Attributes), cgoAllocsUnknown
	allocs192c18d5.Borrow(cattributes_allocs)

	var cclassName_allocs *cgoAllocMap
	ref192c18d5.className, cclassName_allocs = unpackPCharString(x.ClassName)
	allocs192c18d5.Borrow(cclassName_allocs)

	var cparentClass_allocs *cgoAllocMap
	ref192c18d5.parentClass, cparentClass_allocs = *(*C.JSClassRef)(unsafe.Pointer(&x.ParentClass)), cgoAllocsUnknown
	allocs192c18d5.Borrow(cparentClass_allocs)

	var cstaticValues_allocs *cgoAllocMap
	ref192c18d5.staticValues, cstaticValues_allocs = unpackSJSStaticValue(x.StaticValues)
	allocs192c18d5.Borrow(cstaticValues_allocs)

	var cstaticFunctions_allocs *cgoAllocMap
	ref192c18d5.staticFunctions, cstaticFunctions_allocs = unpackSJSStaticFunction(x.StaticFunctions)
	allocs192c18d5.Borrow(cstaticFunctions_allocs)

	var cinitialize_allocs *cgoAllocMap
	ref192c18d5.initialize, cinitialize_allocs = x.Initialize.PassValue()
	allocs192c18d5.Borrow(cinitialize_allocs)

	var cfinalize_allocs *cgoAllocMap
	ref192c18d5.finalize, cfinalize_allocs = x.Finalize.PassValue()
	allocs192c18d5.Borrow(cfinalize_allocs)

	var chasProperty_allocs *cgoAllocMap
	ref192c18d5.hasProperty, chasProperty_allocs = x.HasProperty.PassValue()
	allocs192c18d5.Borrow(chasProperty_allocs)

	var cgetProperty_allocs *cgoAllocMap
	ref192c18d5.getProperty, cgetProperty_allocs = x.GetProperty.PassValue()
	allocs192c18d5.Borrow(cgetProperty_allocs)

	var csetProperty_allocs *cgoAllocMap
	ref192c18d5.setProperty, csetProperty_allocs = x.SetProperty.PassValue()
	allocs192c18d5.Borrow(csetProperty_allocs)

	var cdeleteProperty_allocs *cgoAllocMap
	ref192c18d5.deleteProperty, cdeleteProperty_allocs = x.DeleteProperty.PassValue()
	allocs192c18d5.Borrow(cdeleteProperty_allocs)

	var cgetPropertyNames_allocs *cgoAllocMap
	ref192c18d5.getPropertyNames, cgetPropertyNames_allocs = x.GetPropertyNames.PassValue()
	allocs192c18d5.Borrow(cgetPropertyNames_allocs)

	var ccallAsFunction_allocs *cgoAllocMap
	ref192c18d5.callAsFunction, ccallAsFunction_allocs = x.CallAsFunction.PassValue()
	allocs192c18d5.Borrow(ccallAsFunction_allocs)

	var ccallAsConstructor_allocs *cgoAllocMap
	ref192c18d5.callAsConstructor, ccallAsConstructor_allocs = x.CallAsConstructor.PassValue()
	allocs192c18d5.Borrow(ccallAsConstructor_allocs)

	var chasInstance_allocs *cgoAllocMap
	ref192c18d5.hasInstance, chasInstance_allocs = x.HasInstance.PassValue()
	allocs192c18d5.Borrow(chasInstance_allocs)

	var cconvertToType_allocs *cgoAllocMap
	ref192c18d5.convertToType, cconvertToType_allocs = x.ConvertToType.PassValue()
	allocs192c18d5.Borrow(cconvertToType_allocs)

	x.ref192c18d5 = ref192c18d5
	x.allocs192c18d5 = allocs192c18d5
	return ref192c18d5, allocs192c18d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JSClassDefinition) PassValue() (C.JSClassDefinition, *cgoAllocMap) {
	if x.ref192c18d5 != nil {
		return *x.ref192c18d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JSClassDefinition) Deref() {
	if x.ref192c18d5 == nil {
		return
	}
	x.Version = (int32)(x.ref192c18d5.version)
	x.Attributes = (JSClassAttributes)(x.ref192c18d5.attributes)
	x.ClassName = packPCharString(x.ref192c18d5.className)
	x.ParentClass = *(*JSClassRef)(unsafe.Pointer(&x.ref192c18d5.parentClass))
	packSJSStaticValue(x.StaticValues, x.ref192c18d5.staticValues)
	packSJSStaticFunction(x.StaticFunctions, x.ref192c18d5.staticFunctions)
	x.Initialize = *NewJSObjectInitializeCallbackRef(unsafe.Pointer(&x.ref192c18d5.initialize))
	x.Finalize = *NewJSObjectFinalizeCallbackRef(unsafe.Pointer(&x.ref192c18d5.finalize))
	x.HasProperty = *NewJSObjectHasPropertyCallbackRef(unsafe.Pointer(&x.ref192c18d5.hasProperty))
	x.GetProperty = *NewJSObjectGetPropertyCallbackRef(unsafe.Pointer(&x.ref192c18d5.getProperty))
	x.SetProperty = *NewJSObjectSetPropertyCallbackRef(unsafe.Pointer(&x.ref192c18d5.setProperty))
	x.DeleteProperty = *NewJSObjectDeletePropertyCallbackRef(unsafe.Pointer(&x.ref192c18d5.deleteProperty))
	x.GetPropertyNames = *NewJSObjectGetPropertyNamesCallbackRef(unsafe.Pointer(&x.ref192c18d5.getPropertyNames))
	x.CallAsFunction = *NewJSObjectCallAsFunctionCallbackRef(unsafe.Pointer(&x.ref192c18d5.callAsFunction))
	x.CallAsConstructor = *NewJSObjectCallAsConstructorCallbackRef(unsafe.Pointer(&x.ref192c18d5.callAsConstructor))
	x.HasInstance = *NewJSObjectHasInstanceCallbackRef(unsafe.Pointer(&x.ref192c18d5.hasInstance))
	x.ConvertToType = *NewJSObjectConvertToTypeCallbackRef(unsafe.Pointer(&x.ref192c18d5.convertToType))
}

// unpackArgSJSClassDefinition transforms a sliced Go data structure into plain C format.
func unpackArgSJSClassDefinition(x []JSClassDefinition) (unpacked *C.JSClassDefinition, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.JSClassDefinition) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocJSClassDefinitionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.JSClassDefinition)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.JSClassDefinition)(h.Data)
	return
}

// packSJSClassDefinition reads sliced Go data structure out from plain C format.
func packSJSClassDefinition(v []JSClassDefinition, ptr0 *C.JSClassDefinition) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfJSClassDefinitionValue]C.JSClassDefinition)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewJSClassDefinitionRef(unsafe.Pointer(&ptr1))
	}
}
